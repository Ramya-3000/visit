// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtGEOSXFileReader.C
// ****************************************************************************

#include <avtGEOSXFileReader.h>
#include <GEOSXParser.h>

#include <avtDatabaseMetaData.h>
#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include <InvalidVariableException.h>
#include <InvalidFilesException.h>

#include <vtkCellData.h>
#include <vtkDataArray.h>
#include <vtkDataSet.h>
#include <vtkPointData.h>

using std::map;
using std::set;
using std::string;
using std::vector;


// ****************************************************************************
//  Method: avtGEOSXFileReader constructor
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************

avtGEOSXFileReader::avtGEOSXFileReader(const char *fname,
    const DBOptionsAttributes *) : avtVTKFileReaderBase(), metaFile(fname)
{
    parser = nullptr;
    haveReadMetaFile = false;
}


// ****************************************************************************
//  Method: avtGEOSXFileReader destructor
//
//  Programmer: Kathleen Biagas
//  Creation:   July 5, 2022
//
// ****************************************************************************

avtGEOSXFileReader::~avtGEOSXFileReader()
{
    FreeUpResources();
}


// ****************************************************************************
//  Method: avtGEOSXFileReader::ReadMetaFile
//
//  Purpose:
//    Reads and parses the .vtm file.  Throws an exception if the .vtm file
//    does not contain the elements expected for GEOSX.
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
//  Modifcations:
//
// ****************************************************************************

void
avtGEOSXFileReader::ReadMetaFile()
{
    if(parser)
    {
        delete parser;
    }
    parser = new GEOSXParser;
    parser->SetFileName(metaFile);
    if (!parser->Parse())
    {
        string em = parser->GetErrorMessage();
        delete parser;
        parser = nullptr;
        EXCEPTION2(InvalidFilesException, metaFile, em);
        return;
    }
    int nDataSets = parser->GetNumberOfDataSets();
    datasets.resize(nDataSets);
    for(int i = 0; i < nDataSets; ++i)
    {
        datasets[i] = nullptr;
    }
    haveReadMetaFile = true;
}

// ****************************************************************************
//  Method: avtGEOSXFileReader::ReadDataSet
//
//  Purpose:
//    Reads the dataset associated with meshName and blocknum, storing it
//    as the idx'd datset.
//
//  Arguments:
//    meshName  The mesh name associated with the dataset.
//    blockNum  The block number associated with the dataset.
//    idx       The index into the datset vector.
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
//  Modifcations:
//
// ****************************************************************************

void
avtGEOSXFileReader::ReadDataSet(const string &meshName,
                                const int blockNum,
                                const int idx)
{
    string blockFileName = parser->GetBlockFileName(meshName, blockNum);

    if (datasets[idx] != nullptr)
    {
        datasets[idx]->Delete();
        datasets[idx] = nullptr;
    }
    vtkDataSet *ds = ReadVTKDataset(blockFileName);
    ds->Register(nullptr);
    datasets[idx] = ds;
}



// ****************************************************************************
//  Method: avtGEOSXFileReader::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************


namespace GEOSXFF
{
    // nodal var names associated with each mesh
    map<string, set<string>> meshVarsNodal;
    // zonal var names associated with each mesh
    map<string, set<string>> meshVarsZonal;
    // vars that occur in both nodal and zonal lists
    map<string, vector<string>> meshVarsDuplicate;
    map<string, int> varComponents;
    map<string, int> varTypes;

    void
    FreeUpResources()
    {
        meshVarsNodal.clear();
        meshVarsZonal.clear();
        meshVarsDuplicate.clear();
        varComponents.clear();
        varTypes.clear();
    }

    void
    ReadVars(vtkDataSetAttributes *atts, bool zoneCentered,
             const string &meshName)
    {
        for(int i = 0; i < atts->GetNumberOfArrays(); ++i)
        {
            vtkDataArray *arr = atts->GetArray(i);
            string varName(arr->GetName());
            if(zoneCentered)
                meshVarsZonal[meshName].insert(varName);
            else
                meshVarsNodal[meshName].insert(varName);
            varComponents[varName] = arr->GetNumberOfComponents();
            varTypes[varName] = arr->GetDataType();
        }
    }


    void
    ReadVars(vtkDataSet *ds, const string &meshName)
    {
        ReadVars(ds->GetPointData(), false, meshName);
        ReadVars(ds->GetCellData(), true, meshName);
    }

    void
    ComputeDuplicateVars(const string &meshName)
    {
        set<string> nodeVars = meshVarsNodal[meshName];
        set<string> cellVars = meshVarsZonal[meshName];
        // determine if there are vars duplicated in nodeVars and cellVars.
        // Will need to change the names to var_nodal and var_zonal

        vector<string> var_intersection;
        std::set_intersection(nodeVars.begin(), nodeVars.end(),
                              cellVars.begin(), cellVars.end(),
                              std::back_inserter(var_intersection));

        meshVarsDuplicate[meshName] = var_intersection;
    }


    void
    ConvertSymmetricTensor(vtkDataArray *rv)
    {
        int nt = rv->GetNumberOfTuples();
        vtkDataArray *ten = rv->NewInstance();
        ten->SetNumberOfComponents(9);
        ten->SetNumberOfTuples(nt);
        for (int i = 0; i < nt; ++i)
        {
           double *a = rv->GetTuple6(i);
           double b[9] = {a[0],a[5],a[4],
                          a[5],a[1],a[3],
                          a[4], a[3], a[2]};
           ten->SetTuple(i, &b[0]);
        }
        // reset the size of the array  being returned
        rv->SetNumberOfValues(9*nt);
        rv->SetNumberOfComponents(9);
        rv->ShallowCopy(ten);
        ten->Delete();
    }

} // namespace GEOSXFF


// ****************************************************************************
//  Method: avtGEOSXFileReader::FreeUpResources
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
// ****************************************************************************

void
avtGEOSXFileReader::FreeUpResources(void)
{
    if(parser)
    {
        delete parser;
    }
    parser = nullptr;
    haveReadMetaFile = false;
    GEOSXFF::FreeUpResources();
    avtVTKFileReaderBase::FreeUpResources();

    for (size_t i = 0; i < datasets.size(); ++i)
    {
        if(datasets[i] != nullptr)
            datasets[i]->Delete();
    }
    datasets.clear();
}


// ****************************************************************************
//  Method: avtGEOSXFileReader::PopulateDatabaseMetaData
//
//  Purpose:
//      Sets the database meta data.
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
// ****************************************************************************

void
avtGEOSXFileReader::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    if(!haveReadMetaFile)
    {
        ReadMetaFile();
    }

    // want to read the first block associated with each group within each mesh
    set<string> meshNames = parser->GetMeshNames();
    for (auto meshName : meshNames)
    {
        vector<int> firstBlockPerGroup = parser->GetMeshBlockPerGroup(meshName);
        for(auto i : firstBlockPerGroup)
        {
            int idx = parser->GetDataSetIndex(meshName, i);

            if(datasets[idx] == nullptr)
                ReadDataSet(meshName, i, idx);
            if(datasets[idx] != nullptr)
            {
                GEOSXFF::ReadVars(datasets[idx], meshName);
            }
        }

        GEOSXFF::ComputeDuplicateVars(meshName);

        int idx = parser->GetDataSetIndex(meshName, 0);
        vector<string> &gn = parser->GetMeshGroupNames(meshName);
        vector<string> &bn = parser->GetMeshBlockNames(meshName);
        FillMeshMetaData(md, datasets[idx], meshName,
            int(gn.size()), "group", gn,
            parser->GetMeshGroupIds(meshName),
            int(bn.size()), "block", bn);

        vector<string> dups = GEOSXFF::meshVarsDuplicate[meshName];
        for (auto v : GEOSXFF::meshVarsNodal[meshName])
        {
            int ncomp = GEOSXFF::varComponents[v];
            int dtype = GEOSXFF::varTypes[v];
            string varName = meshName + string("/") + v;
            if (std::find(dups.begin(), dups.end(), v) != dups.end())
            {
                varName += "_nodal";
            }
            FillSingleVarMetaData(md, meshName, varName, ncomp, dtype,
                                  AVT_NODECENT);
        }
        for (auto v : GEOSXFF::meshVarsZonal[meshName])
        {
            int ncomp = GEOSXFF::varComponents[v];
            int dtype = GEOSXFF::varTypes[v];
            string varName = meshName + string("/") + v;
            if (std::find(dups.begin(), dups.end(), v) != dups.end())
            {
                varName += "_zonal";
            }
            FillSingleVarMetaData(md, meshName, varName, ncomp, dtype,
                                  AVT_ZONECENT);
        }
    }
}


// ****************************************************************************
//  Method: avtGEOSXFileReader::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.
//
//  Arguments:
//      blockNum    The block index.
//      meshname    The name of the mesh of interest.
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
// ****************************************************************************

vtkDataSet *
avtGEOSXFileReader::GetMesh(int blockNum, const char *meshname)
{
    if(!haveReadMetaFile)
    {
        ReadMetaFile();
    }

    int idx = parser->GetDataSetIndex(meshname, blockNum);
    if(datasets[idx] == nullptr)
    {
        ReadDataSet(meshname, blockNum, idx);
    }
    if(datasets[idx] == nullptr || datasets[idx]->GetNumberOfPoints() == 0)
    {
        return nullptr;
    }

    currentMeshName = meshname;
    vtkDataSet *dataset = datasets[idx];
    dataset->Register(nullptr);
    return dataset;
}


// ****************************************************************************
//  Method: avtGEOSXFileReader::GetVar
//
//  Purpose:
//      Gets a variable associated with this file.
//
//  Arguments:
//      blockNum   The block index.
//      varname    The name of the variable requested.
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
// ****************************************************************************

vtkDataArray *
avtGEOSXFileReader::GetVar(int blockNum, const char *varname)
{
    if(currentMeshName.empty())
    {
        debug3 << "Could not retrieve Variable " << varname
               << ", expected Mesh to be retrieved first." << endl;
        return nullptr;
    }
    int idx = parser->GetDataSetIndex(currentMeshName, blockNum);
    if(datasets[idx] == nullptr)
    {
        ReadDataSet(currentMeshName, blockNum, idx);
    }

    vtkDataSet *dataset = datasets[idx];
    vtkDataArray *rv = nullptr;
    string realVar(varname);

    size_t pos = realVar.find(currentMeshName);
    realVar.erase(pos, currentMeshName.length()+1);

    int vcenter = 0; // 0 = unknown, 1 = nodal, 2 = zonal;
    pos = realVar.find("_nodal");
    if (pos != string::npos)
    {
        vcenter = 1;
        realVar.erase(pos, 6);
    }
    else
    {
        pos = realVar.find("_zonal");
        if (pos != string::npos)
        {
            vcenter = 2;
            realVar.erase(pos, 6);
        }
    }


    if (vcenter == 0 || vcenter == 1)
    {
        rv = dataset->GetPointData()->GetArray(realVar.c_str());
    }
    if (rv == nullptr && (vcenter == 0 || vcenter == 2))
    {
        rv = dataset->GetCellData()->GetArray(realVar.c_str());
    }
    if (rv == nullptr)
    {
        debug3 << "Could not find Variable: " << realVar << endl;
    }
    else
    {
        if (rv->GetNumberOfComponents() == 6)
        {
            // Assume symmetric tensor and convert this 6-component
            // array into 9 components in voight order
            GEOSXFF::ConvertSymmetricTensor(rv);
        }
        rv->Register(nullptr);
    }
    return rv;
}


// ****************************************************************************
//  Method: avtGEOSXFileReader::GetTime
//
//  Purpose: Return the time associated with this file
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
//  Modifications:
//
// ****************************************************************************

double
avtGEOSXFileReader::GetTime()
{
    if (INVALID_TIME == vtk_time && !haveReadMetaFile)
        ReadMetaFile();
    return vtk_time;
}


// ****************************************************************************
//  Method: avtGEOSXFileReader::GetCycle
//
//  Purpose: Return the cycle associated with this file
//
//  Programmer: Kathleen Biagas
//  Creation:   July 7, 2022
//
//  Modifications:
//
// ****************************************************************************

int
avtGEOSXFileReader::GetCycle()
{
    if (INVALID_CYCLE == vtk_cycle && !haveReadMetaFile)
        ReadMetaFile();
    return vtk_cycle;
}

